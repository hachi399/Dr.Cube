<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3段階連想ブレインストーム（密レイアウト - 安定版）</title>
  <style>
    body{margin:0;font-family:system-ui,Inter,Roboto,sans-serif;background:#fafafa}
    #graph{width:100vw;height:100vh;background:#fff}
    .controls{position:fixed;top:10px;left:10px;display:flex;gap:8px;align-items:center;background:rgba(255,255,255,0.95);padding:8px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.06);z-index:10}
    input{padding:8px 10px;font-size:14px;border:1px solid #ddd;border-radius:6px}
    button{padding:8px 12px;font-size:14px;border-radius:6px;border:none;background:#ff7b50;color:#fff;cursor:pointer}
    button[disabled]{opacity:0.6;cursor:default}
    .notice{font-size:13px;color:#666}
    .tooltip{position:fixed;pointer-events:none;padding:6px 10px;background:rgba(0,0,0,0.85);color:#fff;border-radius:6px;font-size:12px;z-index:10000;display:none;max-width:320px}
  </style>
</head>
<body>
  <div class="controls">
    <input id="seedInput" type="text" placeholder="親ノード名（例：音楽）" />
    <button id="addSeedBtn">生成（親→子6→孫3×6）</button>
    <div class="notice">※孫ノード以上は生成しません</div>
  </div>

  <svg id="graph"></svg>
  <div id="tooltip" class="tooltip"></div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // 状態
    let nodes = [];
    let links = [];
    let idCounter = 0;

    const svg = d3.select('#graph');
    const tooltip = d3.select('#tooltip');
    const getW = () => window.innerWidth;
    const getH = () => window.innerHeight;
    svg.attr('width', getW()).attr('height', getH());

    // レイアウトパラメータ
    const LINK_PARENT_CHILD = 45;
    const LINK_CHILD_GRAND = 60;

    // 力学レイアウト（全体をやや密に保つ）
    const simulation = d3.forceSimulation()
      .force('link', d3.forceLink().id(d=>d.id).distance(link => {
        const sDepth = (link && link.source && typeof link.source.depth === 'number') ? link.source.depth : 0;
        const tDepth = (link && link.target && typeof link.target.depth === 'number') ? link.target.depth : 1;
        return (sDepth === 0 && tDepth === 1) ? LINK_PARENT_CHILD : LINK_CHILD_GRAND;
      }))
      .force('charge', d3.forceManyBody().strength(-80))
      .force('center', d3.forceCenter(getW()/2, getH()/2))
      .force('collision', d3.forceCollide(22))
      .on('tick', ticked);

    const linkG = svg.append('g').attr('class','links');
    const nodeG = svg.append('g').attr('class','nodes');

    function makeId(){ return 'n' + (++idCounter); }
    function findNodeById(id){ return nodes.find(n=>n.id===id); }

    // API キー（ブラウザに直接埋める場合は注意）
    // Render のバックエンドURL（API キーはサーバー側で管理）
    const API_URL = "https://dr-cube-1.onrender.com/chat";

    // 汎用: 指定数を返す fetchWords(word, count)
    async function fetchWords(word, count = 6){
      try{
        const res = await fetch(API_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            message: `「${word}」から連想される短い単語を${count}つ、日本語で出してください。出力は単語のみ、改行かカンマで区切ってください。より突飛な連想でよろしく`
          })
        });

        const json = await res.json();
        let text = '';
        
        // Render のレスポンス形式に合わせて抽出
        if(json.reply && typeof json.reply === 'string'){
          text = json.reply;
        } else if(json.message && typeof json.message === 'string'){
          text = json.message;
        } else if(json.text && typeof json.text === 'string'){
          text = json.text;
        }

        if(!text) return [];
        const parts = String(text).split(/[,\u3001\n]+/).map(s=>s.trim()).filter(Boolean);
        return parts.slice(0, count);
      }catch(err){
        console.error('fetchWords error', err);
        return [];
      }
    }

    // 連想理由取得
    async function fetchReason(a, b){
      try{
        const prompt = '次の2つの概念「' + a + '」と「' + b + '」の関連性を、因果・機能・共通性・背景などを踏まえて日本語で2〜3行にまとめてください。簡潔にお願いします。';
        const res = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: prompt })
        });
        const json = await res.json();
        let text = '';
        
        if(json.reply && typeof json.reply === 'string') text = json.reply;
        else if(json.message && typeof json.message === 'string') text = json.message;
        else if(json.text && typeof json.text === 'string') text = json.text;
        
        return (text && text.trim()) ? text.trim() : (a + ' と ' + b + ' の関連');
      }catch(e){ 
        console.error('fetchReason', e); 
        return a + ' → ' + b + ' の関連'; 
      }
    }

    // addNode: depth 0=親,1=子,2=孫
    function addNode(name, parentId=null, depth=0){
      const n = { id: makeId(), name, depth };
      let px = getW()/2, py = getH()/2;
      if(parentId){ const p = findNodeById(parentId); if(p && typeof p.x === 'number'){ px = p.x; py = p.y; } }
      const ang = Math.random()*Math.PI*2;
      const baseDist = parentId ? 40 : 20;
      n.x = px + Math.cos(ang)*baseDist;
      n.y = py + Math.sin(ang)*baseDist;

      nodes.push(n);

      if(parentId){
        const pNode = findNodeById(parentId);
        const linkObj = { id: 'l' + links.length, source: pNode, target: n, reason: '連想理由を生成中...' };
        links.push(linkObj);
        fetchReason(pNode.name, n.name).then(r => { linkObj.reason = r || `${pNode.name} → ${n.name}`; });
      }

      return n;
    }

    function restart(){
      const linkSel = linkG.selectAll('g.link').data(links, d=>d.id);
      linkSel.exit().remove();
      const linkEnter = linkSel.enter().append('g').attr('class','link');
      linkEnter.append('line').attr('class','hit').attr('stroke','transparent').attr('stroke-width',20);
      linkEnter.append('line').attr('class','visible').attr('stroke','#bfbfbf').attr('stroke-width',2);
      const linkMerge = linkEnter.merge(linkSel);

      linkMerge.on('mouseover', (event,d)=>{ tooltip.style('display','block').text(d.reason || ''); })
        .on('mousemove', event=>{ tooltip.style('left',(event.pageX+12)+'px').style('top',(event.pageY+12)+'px'); })
        .on('mouseout', ()=>{ tooltip.style('display','none'); });

      const nodeSel = nodeG.selectAll('g.node').data(nodes, d=>d.id);
      nodeSel.exit().remove();
      const nodeEnter = nodeSel.enter().append('g').attr('class','node');
      nodeEnter.append('circle').attr('r',16).attr('fill','#ffdca8').attr('stroke','#e6a86b').attr('stroke-width',2);
      nodeEnter.append('text').attr('dy',4).attr('text-anchor','middle').style('font-size','11px').text(d=>d.name);

      simulation.nodes(nodes);
      simulation.force('link').links(links);
      simulation.alpha(0.9).restart();
    }

    function ticked(){
      nodeG.selectAll('g.node').attr('transform', d=>`translate(${d.x},${d.y})`);
      linkG.selectAll('g.link').each(function(d){
        d3.select(this).select('line.hit').attr('x1',d.source.x).attr('y1',d.source.y).attr('x2',d.target.x).attr('y2',d.target.y);
        d3.select(this).select('line.visible').attr('x1',d.source.x).attr('y1',d.source.y).attr('x2',d.target.x).attr('y2',d.target.y);
      });
    }

    // ボタン処理
    document.getElementById('addSeedBtn').addEventListener('click', async ()=>{
      const seed = document.getElementById('seedInput').value.trim();
      if(!seed){ alert('親ノード名を入力してください'); return; }

      const btn = document.getElementById('addSeedBtn');
      btn.disabled = true;
      btn.textContent = '生成中...';

      try{
        nodes = []; links = []; idCounter = 0; restart();

        const parent = addNode(seed, null, 0);
        restart();

        const childWords = await fetchWords(seed, 6);
        while(childWords.length < 6) childWords.push(seed + '_child');
        
        for(const c of childWords){
          const child = addNode(c, parent.id, 1);
          restart();
          await new Promise(r=>setTimeout(r, 80));
          
          const grandWords = await fetchWords(c, 3);
          while(grandWords.length < 3) grandWords.push(c + '_grand');
          for(const g of grandWords){ 
            addNode(g, child.id, 2); 
          }
          restart();
        }
      }finally{
        btn.disabled = false;
        btn.textContent = '生成（親→子6→孫3×6）';
        document.getElementById('seedInput').value = '';
      }
    });

    // レスポンシブ
    window.addEventListener('resize', ()=>{
      svg.attr('width', getW()).attr('height', getH());
      simulation.force('center', d3.forceCenter(getW()/2, getH()/2));
      simulation.alpha(0.3).restart();
    });
  </script>
</body>
</html>
